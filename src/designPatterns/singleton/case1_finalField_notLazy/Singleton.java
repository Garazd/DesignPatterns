package designPatterns.singleton.case1_finalField_notLazy;

// самая простая реализация, безопасная для многопоточного использования, но не ленивая

// ленивая - значит что только когда клиент явно попросит, произойдет инстанциирование
// единственного экземпляра, а тем временем ничего не инициализируется
// у нас не ленивая - значит конструктор вызовется тогда, когда впервые будет упоминание
// об этом классе в классе-клиенте

// многопточно-безопасная значит, что несоклько потоков могут без ошибок пользоваться
// этим классом детерминированно, то есть презсказуемо получая всегда один и тот же
// экземпляр, причем не будет создано более одного экземпляра, какие бы комбинации
// вызовов из разынх потоков мы бы не придумали

// есть еще один недостаток - мы не сможем отловить исключение, которое может
// возникнуть в конструкторе синглтона (например провода, по которым мы хотели
// подключиться к базе данных украли марсиане)

// класс final, чтобы не занаследоваться
public final class Singleton {

    // закрытое, только для чтения, статическое поле с автоматической инициализацией
    private static final Singleton instance = new Singleton();

    // и открытый статический геттер для него
    // можно было и без него вообще
    public static Singleton getInstance() {
        return instance;
    }

    // конструктор закрыт, чтобы никто не смог получить второй экземпляр
    private Singleton() {
        // какие-то сложные вычисления, которые мы хотим, чтобы выполнялись единожды
        System.out.println("Инстанциировали Singleton!");
    }
}