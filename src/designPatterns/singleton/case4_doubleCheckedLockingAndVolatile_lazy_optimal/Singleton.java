package designPatterns.singleton.case4_doubleCheckedLockingAndVolatile_lazy_optimal;

// ленивая реализация с оптимальной защитой для многопоточного использования
// критической секцией окружен код записи, но не чтения
public final class Singleton {

    // статическое поле - такая себе глобальная для всех переменная

    // volatile она тут за тем, чтобы обезопасить доступ
    // за деталями смотри в http://habrahabr.ru/post/129494/
    // кстати Автору за статью Спасибо!
    private static volatile Singleton instance;

    // открытый статический метод доступа
    public static Singleton getInstance() {
        // скопировали ссылку на инстанс, чтобы гарантированно получить ее в наш стек
        // каждый поток имеет свой стек
        // еще тут могут быть несколько потоков
        // и в самом начале кто-то из них получит null,
        // а кто-то уже ссылку на реальный экземпляр
        Singleton local = instance;
        // потому мы проверим, а не null ли экземпляр
        // что не гарантирует, что экземпляр не создан уже
        // оно лишь говорит, что в момоент получения
        // ссылки instance в local оно таки было null
        // может и сейчас так, а может и нет :)
        if (local == null) {
            // критическая секция только на записи
            // тут выстраиваются в очередь все потоки, которые определили,
            // что на момент копирования ссылки из instance в local она была null
            // то есть они соревнуются за первенство - кто же всетаки создаст экземпляр
            synchronized (Singleton.class) {
                // тут всегда только один поток - это критическая секция
                // лочимся на объекте класса Singleton, а потому точно для всех потоков

                // тут возможна трабла, когда кто-то извне уже захватил монитор этого объекта
                // потому часто лочатся по
                // private static final Object lock = new Object();
                // так безопаснее

                // копируем еще раз ссылку, потому что может быть пока мы стояли в очереди
                // перед критической секцией, другой поток уже успел проинициализировать
                // экземпляр и он уже не null
                local = instance;

                // делаем вторую проверку
                if (local == null) {
                    // если мы первые - инстанциируем
                    // присваивая сразу и полю и локальной переменной ссылку на экземпляр
                    instance = local = new Singleton();
                }
            }
        }
        // возвращаем ссылку на экземпляр, тут она точно будет не null
        // потому что либо мы сами ее инициализировали - если первые
        // либо получили ее в клитической секции до второй проверки - одни из первых
        // либо получили ее до первой проверки - все сотальные 99.99% случаев вызова getInstance()
        return local;
    }

    // все тот же приватный конструктор
    private Singleton() {
        // какие-то сложные вычисления, которые мы хотим, чтобы выполнялись единожды
        System.out.println("Инстанциировали Singleton!");
    }
}