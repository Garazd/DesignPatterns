package designPatterns.singleton.case3_synchronizedAccessor_lazy_notOptimal;

// ленивая реализация с примитивной защитой для многопоточного использования
public final class Singleton {

    // статическое поле - такая себе глобальная для всех переменная
    private static Singleton instance;

    // открытый статический метод доступа
    // синхронизирован полностью, а значит защищен
    // только один поток сможет войти в этот метод - другие будут
    // ждать на входе в метод, пока из него не выйдет первый поток

    // защищать надо только момент инстанциирования (записи) - то есть только 1 раз
    // но так как засинхронизирован весь метод, то он будет навсегда узким
    // бутылочным горлышком. Начиная со второго вызова, синхронизация уже не нужна
    // мы не пишем, а только читаем из разных потоков, но она есть и
    // потому реализация считается не оптимальной.
    public static synchronized Singleton getInstance() {
        // если экземпляр еще не создан
        if (instance == null) {
            // создаем его и сохраняем в статическое поле
            instance = new Singleton();
        }
        // в любом случае возвращаем то что есть
        return instance;
    }

    // в одну строчку :)
    // если воспользоваться тернарным if выражением
    // и знанием что в java можно сделать так
    // Object o5 = o4 = o3 = o2 = o1 = new Object();
    //    public static synchronized Singleton getInstance() {
    //        return (instance == null)?instance = new Singleton():instance;
    //    }

    // все тот же приватный конструктор
    private Singleton() {
        // какие-то сложные вычисления, которые мы хотим, чтобы выполнялись единожды
        System.out.println("Инстанциировали Singleton!");
    }
}